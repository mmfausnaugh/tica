#!/usr/bin/env python
#
#
#Copyright (c) 2021 Michael Fausnaugh
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the Software), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

import sys
import os
import numpy as np
import matplotlib.pyplot as plt
import argparse
import logging
from multiprocessing import Pool
from time import time
import re

DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(DIR, '..'))

import scipy as sp
import matplotlib.pyplot as plt

import tica
from tica.tica import Calibration, Sector, CCD, CCD_File, FFI_File

#def worker(filename, calibration=None, outdir="."):
def worker( in_tuple ):
    filename = in_tuple[0]
    outdir = in_tuple[1]
    trim = in_tuple[2]
    orbit_segment = in_tuple[3]
    no_gzip = in_tuple[4]

    #it knows about calibration as a global variable...very yucky...
    im = FFI_File(filename, 
                  calibration=calibration, 
                  outdir=outdir,
                  orbit_segment = orbit_segment)

    if trim:
        im.write_calibrated_trimmed_CCDs(
            no_gzip = no_gzip)
    else:
        im.write_calibrated_CCDs(
            no_gzip = no_gzip)

if __name__ == "__main__":

    description_string = """

    This script calibrates raw FFI FITS files.

    The list of FITS files to calibrate should be be saved in a plain text
    file, with one file per line.  The text file is the positional argument for this script.

    The input FITS files need to be saved as combined camera FITS files, as
    used by the TESS Science Office (TSO) and Payload Operations
    Center (POC).  These files are not publicly available at this time.

    The calibrated files will be saved as individual CCDs in FITS
    format, with a `_ccd?.cal.` string added to the names.

    """

    parser = argparse.ArgumentParser(prog='tica', description=description_string)
    parser.add_argument("fileinputs", metavar="FILE", help="text file containing a list of FITS files to process")
    parser.add_argument("--outdir", metavar="DIRECTORY", help="directory in which to place the results")
    parser.add_argument("--caldir", metavar="DIRECTORY", default=None,
                        help="calibration directory")
    parser.add_argument("--version", action="version", version="tica %s" % tica.version)
    parser.add_argument("--parallel", type=int, default=1,
                        help="run files in parallel on number of processors specified here")
    parser.add_argument("--trim", action="store_true", help="trim calibration pixels from edges")
    parser.add_argument("-d", "--debug", action="store_true", help="emit extra diagnostic information to log")
    parser.add_argument("-l", "--log", metavar="LOG_FILE", default='tica.log', 
                        help="save logging output to this file")
    parser.add_argument("--orb_seg", type=str, help="if set, write ORB_SEG header keyword in calibrated files.")
    parser.add_argument("--no_gzip",action="store_true", help="if set, do not write gzipped files regardless of input file extension.")

    args = parser.parse_args()

    #each time we run tica, copy the old log file
    #this forces tica.log to match tica_wcs_step2*log
    if os.path.isfile(args.log):
        jj = 1
        while True:
            if os.path.isfile(args.log + '_run{}'.format(jj) ):
                jj += 1
            else:
                os.rename(args.log, args.log + '_run{}'.format(jj) )
                break

    # setup logging
    tica.setup_logging(debug=args.debug, filename=args.log)
    logger = logging.getLogger(__name__)
    info_lines = tica.platform_info()
    for info_line in info_lines:
        logger.info(info_line)
    logger.info('python environment:  {}'.format(  os.getenv('CONDA_DEFAULT_ENV') )  )
    logger.info('program: {}'.format( parser.prog ) )
    logger.info('working directory {}'.format(os.getcwd() ))
    logger.info('argument parameters:')
    for key in vars(args).keys():
        logging.info('     {} = {}'.format(key, vars(args)[key]) )

    if args.outdir:
        outdir=args.outdir
    else:
        outdir="."  # if outdir is not set, default to current directory

    try:
        inlist = np.genfromtxt(args.fileinputs, dtype=str)
    except IOError:
        logger.error("input file not found: %s" % args.fileinputs)
        sys.exit(1)


    orbits, stamps = [],[]
    for filename in inlist:
        try:
            search_obj = re.search('orbit-(\d*)\D*tess(\d*)-',filename)
            orbits.append( int(search_obj.group(1)) )
            stamps.append( int(search_obj.group(2)) )
        except AttributeError:
            set_orb_seg = False
            orbits.append( int(1) )
            stamps.append( int('dummy') )


    orbits = np.array(orbits)
    stamps = np.array(stamps)
    #we can get o1 or o2 from even and odd orbits
    #we can get a and b if there are 2 unique time stamps
    #we can't know if it is a or b by itself
    #also, the logical fails if you calibrate two sectors
    #at the same time

    #assume a single time stamp is a

    #if processing off nominal, don't write this keyword,
    #do not write keyword as default; only set it if we know what we are doing

    m_odd  = orbits%2 == 1
    odd_segments = {}
    for ii,stamp in enumerate(  np.unique(stamps[m_odd])):
        if ii == 0:
            odd_segments[stamp] = 'a'
        if ii == 1:
            odd_segments[stamp] = 'b'


    m_even = orbits%2 == 0    
    even_segments = {}
    for ii,stamp in enumerate(  np.unique(stamps[m_even])):
        if ii == 0:
            even_segments[stamp] = 'a'
        if ii == 1:
            even_segments[stamp] = 'b'


    orbit_seg = []
    for ii in range(len(orbits)):        
        #assumes odd orbits are first, even orbits 2nd
        if orbits[ii]%2 == 1:
            orbit_seg_str = 'o1'
            orbit_seg_str += odd_segments[stamps[ii]]

        elif orbits[ii]%2 == 0:
            orbit_seg_str = 'o2'
            orbit_seg_str += even_segments[stamps[ii]]

        if args.orb_seg:
            orbit_seg.append(  orbit_seg_str )
        else:
            orbit_seg.append(None)

    if len(args.orb_seg) == 0:
        args.orb_seg = None
    
    # setup calibration object before processing files so it is done just once
    if args.caldir:
        calibration = Calibration(calibration_dir=args.caldir)
    else:
        calibration = None

    if calibration is None:
        logger.error("No calibration dir specified.  You must choose"
                     "calibration models appropriate for the exposure time")
        sys.exit(1)

    starttime = time()

    if args.parallel > 1:
        p = Pool(args.parallel)
        for ii, filename in enumerate(inlist):
            p.apply_async(worker, ( (filename, outdir, 
                                     args.trim, args.orb_seg, 
                                     args.no_gzip, ), ))
        p.close()
        p.join()
    else:
        for ii,filename in enumerate(inlist):
            worker( (filename,  outdir, 
                     args.trim, args.orb_seg,
                     args.no_gzip, ),)
    runtime = time() - starttime

    print("Runtime: {0:.2f}sec".format(runtime), "N Pools = {}".format( args.parallel ) )
    logger.info("N Pools = {}".format( args.parallel ) )
    logger.info("Runtime: {0:.2f}sec".format(runtime) )
